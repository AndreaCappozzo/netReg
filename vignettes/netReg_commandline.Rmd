---
title: "netReg commandline tutorial"
bibliography: netReg.bib
---

This document explains how to install and use the `netReg` command line tool.

## Installation

You have two options for installing the command line tool. You can either

* use [bioconda](https://anaconda.org/bioconda/netreg),
* or install the tool manually.

### Installation with bioconda

The best way to install `netReg` is using *conda*. 
For that you should download [Anaconda](https://www.continuum.io/downloads) and create a [virtual environment](https://conda.io/docs/using/envs.html).
Then install the tool using:

```sh
  conda install -c bioconda netreg
  
  netReg -h
```

This would install the package from the *bioconda* channel (a highly recommented platform) and then test if the tool is installed.

### Manual installation

Alternatively you can of course install `netReg` manually. The **command line tool has the following dependencies**:

* `CMake >= 3.6`,
* `Boost >= 1.6.x`,
* `Armadillo >= 7.800.3`,
* `OpenBLAS/BLAS` and `Lapack` (older versions should work),
* *optional*: `OpenMP` (older versions should work).

Then download the tarball of the latest [release](https://github.com/dirmeier/netReg/releases/). We use `CMake` for building the package. You can use it like this:

```sh
  mkdir build && cd build
  cmake .. && make
  
  ./netReg -h
```

This builds the package in folder `build` and then tests if the package is installed. 
In case you want to install it properly subsequently use:

```sh
  (sudo) make install --prefix=/some/path
```

## Usage

This section explains how to fit a linear model and do parameter estimation. 
Using the command line tool is rather straightforward. First let's call `netReg` without parameters to 
see how it is used:

```sh
  netReg -h
  
  netReg - a network-regularized generalized regression model

  Arguments:
    -h [ --help ]                        Print this help.
    -d [ --design ] arg                  Filename of the design matrix X.
    -u [ --gx ] arg                      Filename of the affinity matrix GX for X.
    -r [ --reponse ] arg                 Filename of the reponse matrix Y.
    -v [ --gy ] arg                      Filename of the affinity matrix GY for Y.
    -l [ --lambda ] arg (=1)             LASSO penalization parameter.
    -s [ --psi ] arg (=0)                Penalization parameter for affinity
                                         matrix GX.
    -x [ --xi ] arg (=0)                 Penalization parameter for affinity
                                         matrix GY.
    -m [ --maxit ] arg (=100000)         Maximum number of iterations of
                                         coordinate descent. You should choose a
                                         sufficiently large number.
    -t [ --threshold ] arg (=0.0000001)  Convergence threshold for coordinate
                                         descent. Anything below 0.0001 should
                                         suffice.
    -o [ --outfile ] arg                 Filename of the output file.
    
    Model selection:
    --modelselection                     Use modelselection, i.e. estimation of
                                         optimal shrinkage parameters using
                                         crossvalition, before doing the
                                         estimation of coefficients.
    -n [ --nfolds ] arg (=10)            The number of cross-validation folds.
                                         This can be maximal the number of rows
                                         of X/Y and minimal 3.
    -e [ --epsilon ] arg (=0.001)        Convergence threshold for the BOBYQA
                                         algorithm, i.e. the stop criterion for
                                         the model selection.
    -b [ --bobit ] arg (=1000)           Maximal number of iterations for the
                                         BOBYQA algorithm.
```

This gives a list of required arguments. We have provided some example data files in the GitHub
repository [here](https://github.com/dirmeier/netReg/tree/master/data) to test the package.

### Examples

An exemplary call could look like this:

```sh
  netReg -d X.tsv -r Y.tsv -v GY.tsv 
         -l 10 -x 1 --maxit 1000 --threshold 0.0001 
         -o outfile.tsv
```

In this example we use a design matrix given in `X.tsv` and response matrix `Y.tsv`. For the response variables we use an affinity matrix that represents *biological relationships* with `GY.tsv`. We promote sparsity by setting $\lambda = 10$ and put a week penalty on similar coefficients by setting $\xi = 1 $. We stop the algorithm after maximal $1000$ iterations or if a convergence threshold of $0.0001$ is reached. The coefficients are written to `outfile.tsv`.

Usually we don't know these parameters, but need to estimate them such that the correct parameterization gives us the *best* model. In that case we would call

```sh
  netReg --modelselection 
         -d X.tsv -r Y.tsv -v GY.tsv 
         -b 100 
         -o outfile.tsv
```

This estimates $\lambda$ and $\xi$ and writes them to `outfile.tsv`. 
Since we did not provide an affinity matrix for the design matrix we do not estimate $\psi$. The optimization uses the `BOBYQA` algorithm by Powell [@powell2009bobyqa]. Since for such a complex likelihood as we use it this takes time, we only iterate `BOBYQA` $100$ times here. Other than that we use default parameters here.

## References
