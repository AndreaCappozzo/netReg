---
title: "netReg R tutorial"
bibliography: netReg.bib
---

This document explains how to install and use the `R` package.

## Installation

You can install and use `netReg` either

* as an `R` library from [Bioconductor](https://bioconductor.org/packages/release/bioc/html/netReg.html),
* or by downloading the `tarball`.

### Installation with Bioconductor

The easiest way to install `netReg` is using the `R`-console:

```{r, eval=FALSE}
  source("https://bioconductor.org/biocLite.R")
  biocLite("netReg")
  
  library(netReg)
```
 
### Manual installation
 
If you want to build the package yourself first download the `tarball` of the latest [release](https://github.com/dirmeier/netReg/releases/) and then call:

```bash
  R CMD install <netReg-x.y.z.tar.gz>
```
 
That's it.
 
## Usage

This section explains how to fit a linear model and do parameter estimation. 

At first we load the library and some data:

```{r, eval=FALSE}
> library(netReg)
> data("yeast")

> ls(yeast)
> [1] "GY" "X"  "Y" 
```

The `yeast` data `X` and `Y` set is taken and adopted from [@brem2005genetic], [@storey2005multiple], and [@cheng2014graph]. $\mathbf{GY}$ is taken from [BioGRID](https://thebiogrid.org/downloads/archives/Release%20Archive/BIOGRID-3.4.150/BIOGRID-ORGANISM-3.4.150.tab.zip). `X` is a `(n x p)` matrix of genetic markers where `n` is the number of samples (112) and `p` is the number of markers. The data has been taken from Brem <i>et al.</i>, Nature (2005).
* `Y` is a `(n x q)` matrix of expression values for `q` yeast genes. `n` is again the numer of samples (112).
* `GY` is a `(q x q)` adjacency matrix representing protein-protein interactions for the `q` response variables.

### Model fitting

Fitting a model using edge-based regularization with `netReg` is easy:

```{r, eval=FALSE}
  fit <- edgenet(X=yeast$X, Y=yeast$Y, G.Y=yeast$GY,
                 lambda=10, psigy=1, family="gaussian")
  print(fit)
```

For the response variables we use an affinity matrix that represents *biological relationships* with `GY`.

In this case we used a single affinity matrix `G.X` which represents the
relationship of the covariables $\mathit{X}$. If the design matrix has $p$ 
variables, `G.X` has to be an $(p \times p)$-dimensional symmetric matrix. 
We can also include a matrix for the response matrix `Y` with $q$ dependent 
variables. In that case the affinity matrix `G.Y` has to be 
$(q \times q)$-dimensional (and also symmetric).

The `fit` object contains information about coefficients, intercepts, 
residuals, etc. Having the coefficients estimated we are able to
predict novel data-sets:

```{r, eval=FALSE}
    X.new <- matrix(rnorm(10*5),10)
    pred  <- predict(fit, X.new)
```

The `pred` objects contains the predicted values for the responses.

### Model selection

In most cases we do not have the optimal shrinkage parameters $\lambda$, 
$\psi_{gx}$ and $\psi_{gy}$. For these settings you can use `netReg`'s 
included model selection. We use Powell's BOBYQA algorithm 
([@powell2009bobyqa]) for gradient-free optimization that is included in the
`C++` library `Dlib`. Doing the model selection only requires calling 
`cv.edgnet`:

```{r, eval=FALSE}
    cv <- cv.edgenet(X=X, Y=Y, G.X=aff.mat, family="gaussian", maxit=1000)
    print(cv)
```

You can use the fitted parameters for the normal `edgenet` function. 
In this scenario $\lambda$, $\psi_{gx}$ and $\psi_{gy}$ should be 
roughly $0$ for three reasons:

* we had enough data and a small number of covariables ($n > p$), so we can 
find the *BLUE* estimator,
* we created `X` and `Y` independent of each other,
* our prior graph `aff.mat` had little weight.

Let's do a scenario where we need to shrink some coefficients, i.e. $n \ll p$.
We choose a small $p$, such that the computation does not take too long.

```{r, eval=FALSE}
    p <- 25
    X <- matrix(rnorm(10*p), 10)
    Y <- matrix(rnorm(10*p), 10)
    aff.mat <- matrix(rgamma(p * p, 5, 1), p)
    aff.mat <- (t(aff.mat) + aff.mat)
    diag(aff.mat) <- 0
    cv <- cv.edgenet(X=X, Y=Y, G.X=aff.mat, family="gaussian", maxit=1000)
    print(cv)
```

In the above example $\lambda$ should have changed quite a bit, while
$\psi_{gy}$ should still be $0$. Since we generated `aff.mat` randomly 
$\psi_{gx}$ should be roughly (or exact) zero as well. This makes sense 
intuitively since we did not put any biological relationships into the 
affinity matrices.

## References
